{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "import torch.utils.data\n",
    "import torch.optim as optim\n",
    "import numpy as np\n",
    "import argparse\n",
    "import time\n",
    "import math\n",
    "import random\n",
    "import json\n",
    "import pathlib\n",
    "from torchinfo import summary\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from torch.autograd import Variable\n",
    "from PIL import Image\n",
    "import math\n",
    "from model.Flow import Planar\n",
    "\n",
    "class GraphicalVINF(nn.Module):\n",
    "    def __init__(self, args):\n",
    "        super(GraphicalVINF, self).__init__()\n",
    "\n",
    "        # extract model settings from args\n",
    "        self.batch_size = args.batch_size\n",
    "        self.is_cuda = args.cuda\n",
    "        self.log_det_j_LS = 0.\n",
    "        self.log_det_j_LF = 0.\n",
    "        self.log_det_j_BD = 0.\n",
    "        self.num_pseudos = args.num_pseudos # for initialising pseudoinputs\n",
    "        \n",
    "        flowLS = Planar # For normalizing flow\n",
    "        flowLF = Planar\n",
    "        flowBD = Planar\n",
    "        self.num_flows = args.num_flows\n",
    "        self.m = nn.Sigmoid()\n",
    "        \n",
    "        # Normalizing flow layers\n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_LS = flowLS()\n",
    "            self.add_module('flow_LS_' + str(k), flow_k_LS)\n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_LF = flowLF()\n",
    "            self.add_module('flow_LF_' + str(k), flow_k_LF)\n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_BD = flowBD()\n",
    "            self.add_module('flow_BD_' + str(k), flow_k_BD)\n",
    "        \n",
    "        \n",
    "        # Paramters in normalizing flows    \n",
    "        self.mu_LS = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                   nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.var_LS = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                    nn.Softplus(),\n",
    "                                    nn.Hardtanh(min_val=1, max_val=5))\n",
    "        self.amor_u_LS = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_w_LS = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_b_LS = nn.Sequential(nn.Linear(self.batch_size, self.num_flows),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "\n",
    "        self.mu_LF = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                   nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.var_LF = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                    nn.Softplus(),\n",
    "                                    nn.Hardtanh(min_val=1, max_val=5))\n",
    "        self.amor_u_LF = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_w_LF = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_b_LF = nn.Sequential(nn.Linear(self.batch_size, self.num_flows),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "\n",
    "        self.mu_BD = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                   nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.var_BD = nn.Sequential(nn.Linear(self.batch_size, self.batch_size),\n",
    "                                    nn.Softplus(),\n",
    "                                    nn.Hardtanh(min_val=1, max_val=5))\n",
    "        self.amor_u_BD = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_w_BD = nn.Sequential(nn.Linear(self.batch_size, self.num_flows * self.batch_size),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "        self.amor_b_BD = nn.Sequential(nn.Linear(self.batch_size, self.num_flows),\n",
    "                                       nn.Hardtanh(min_val=-1, max_val=1))\n",
    "\n",
    "        #nn.Softplus() = log(1+exp(x))\n",
    "        #Amortized flow parameters\n",
    "        # Parameters Setup\n",
    "        self.w_0LS = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_0LF = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_0BD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_eLS = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_eLF = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_eBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_ex  = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_0x  = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_LSx = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.w_LFx = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.w_LSBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.w_LFBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.w_BDx = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.w_aBD  = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_aLS  = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_aLF  = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.w_gBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float)) \n",
    "        self.t_gBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.t_aBD = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.t_aLS = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))\n",
    "        self.t_aLF = nn.Parameter(torch.rand(1, requires_grad=True, dtype=torch.float))        \n",
    "\n",
    "        self.min_thres = 0.1\n",
    "        self.max_thres = 0.5\n",
    "        if args.cuda:\n",
    "            self.FloatTensor = torch.cuda.FloatTensor\n",
    "        else:\n",
    "            self.FloatTensor = torch.FloatTensor\n",
    "          \n",
    "    def reparameterize(self, mu, var):\n",
    "        \"\"\"\n",
    "        Samples z from a multivariate Gaussian with diagonal covariance matrix using the\n",
    "         reparameterization trick.\n",
    "        \"\"\"\n",
    "        std = var.sqrt()\n",
    "        eps = torch.randn_like(std)\n",
    "        z = eps * std + mu\n",
    "        return self.m(z)\n",
    "\n",
    "    def f(self,y):\n",
    "        return torch.log(1-torch.exp(-y))\n",
    "        \n",
    "    def forward(self, a_LS, a_LF, a_BD, x):      \n",
    "        if self.is_cuda:\n",
    "            self.log_det_j_LS = torch.zeros([x.shape[0]]).cuda()\n",
    "            self.log_det_j_LF = torch.zeros([x.shape[0]]).cuda()\n",
    "            self.log_det_j_BD = torch.zeros([x.shape[0]]).cuda()\n",
    "        else:\n",
    "            self.log_det_j_LS = torch.zeros([x.shape[0]])\n",
    "            self.log_det_j_LF = torch.zeros([x.shape[0]])\n",
    "            self.log_det_j_BD = torch.zeros([x.shape[0]])\n",
    "\n",
    "        a_LS_1 = self.w_aLS*a_LS + self.w_0LS\n",
    "        a_LF_1 = self.w_aLF*a_LF + self.w_0LF\n",
    "        a_LS_1 = self.m(a_LS_1)\n",
    "        a_LF_1 = self.m(a_LF_1)\n",
    "        \n",
    "        \n",
    "        q_LS_mu = self.mu_LS(a_LS_1) \n",
    "        y_LS_var = self.var_LS(a_LS_1)\n",
    "        u_LS = self.amor_u_LS(a_LS_1).view(-1, self.num_flows, self.batch_size, 1)\n",
    "        w_LS = self.amor_w_LS(a_LS_1).view(-1, self.num_flows, 1, self.batch_size)\n",
    "        b_LS = self.amor_b_LS(a_LS_1).view(-1, self.num_flows, 1, 1)\n",
    "        q_LS_var = y_LS_var + self.w_eLS**2    \n",
    "        q_LS = self.reparameterize(q_LS_mu, q_LS_var)\n",
    "        q_LS = [q_LS]  \n",
    "\n",
    "        q_LF_mu = self.mu_LF(a_LS_1) \n",
    "        y_LF_var = self.var_LF(a_LS_1)\n",
    "        u_LF = self.amor_u_LF(a_LS_1).view(-1, self.num_flows, self.batch_size, 1)\n",
    "        w_LF = self.amor_w_LF(a_LS_1).view(-1, self.num_flows, 1, self.batch_size)\n",
    "        b_LF = self.amor_b_LF(a_LS_1).view(-1, self.num_flows, 1, 1)\n",
    "        q_LF_var = y_LF_var + self.w_eLF**2    \n",
    "        q_LF = self.reparameterize(q_LS_mu, q_LS_var)\n",
    "        q_LF = [q_LF]  \n",
    "\n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_LS = getattr(self, 'flow_LS_' + str(k))\n",
    "            q_LSk, log_det_jacobian_LS = flow_k_LS(q_LS[k], u_LS[:, k, :, :], w_LS[:, k, :, :], b_LS[:, k, :, :])\n",
    "            q_LSk = self.m(q_LSk)\n",
    "            q_LS.append(q_LSk)\n",
    "            self.log_det_j_LS = self.log_det_j_LS + log_det_jacobian_LS  \n",
    "            \n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_LF = getattr(self, 'flow_LF_' + str(k))\n",
    "            q_LFk, log_det_jacobian_LF = flow_k_LF(q_LF[k], u_LF[:, k, :, :], w_LF[:, k, :, :], b_LF[:, k, :, :])\n",
    "            q_LFk = self.m(q_LFk)\n",
    "            q_LF.append(q_LFk)\n",
    "            self.log_det_j_LF = self.log_det_j_LF + log_det_jacobian_LF\n",
    "\n",
    "        q_LS_0 = q_LS[0]\n",
    "        q_LF_0 = q_LF[0]\n",
    "        q_LS_K = q_LS[-1]\n",
    "        q_LF_K = q_LF[-1]\n",
    "        \n",
    "        g = torch.ones([self.batch_size,1])\n",
    "        g[(q_LF_K.view(self.batch_size,-1) <= self.min_thres) & (q_LS_K.view(self.batch_size,-1) <= self.min_thres)] = 0\n",
    "        g[(q_LF_K.view(self.batch_size,-1) >= self.max_thres) & (q_LS_K.view(self.batch_size,-1) >= self.max_thres)] = 0\n",
    "        g = g.view(a_LS.size(0),a_LS.size(1))\n",
    "\n",
    "        a_BD_1 = self.w_gBD*g + self.w_aBD*a_BD + self.w_0BD\n",
    "        a_BD_1 = self.m(a_BD_1)\n",
    "\n",
    "        \n",
    "        q_BD_mu = self.mu_BD(a_BD_1) \n",
    "        y_BD_var = self.var_BD(a_BD_1)\n",
    "        u_BD = self.amor_u_BD(a_BD_1).view(-1, self.num_flows, self.batch_size, 1)\n",
    "        w_BD = self.amor_w_BD(a_BD_1).view(-1, self.num_flows, 1, self.batch_size)\n",
    "        b_BD = self.amor_b_BD(a_BD_1).view(-1, self.num_flows, 1, 1)\n",
    "        q_BD_var = y_BD_var + self.w_eBD**2    \n",
    "        q_BD = self.reparameterize(q_BD_mu, q_BD_var)\n",
    "        q_BD = [q_BD]  \n",
    "\n",
    "\n",
    "        for k in range(self.num_flows):\n",
    "            flow_k_BD = getattr(self, 'flow_BD_' + str(k))\n",
    "            q_BDk, log_det_jacobian_BD = flow_k_BD(q_BD[k], u_BD[:, k, :, :], w_BD[:, k, :, :], b_BD[:, k, :, :])\n",
    "            q_BDk = self.m(q_BDk)\n",
    "\n",
    "            q_BD.append(q_BDk)\n",
    "            self.log_det_j_BD = self.log_det_j_BD + log_det_jacobian_BD \n",
    "        q_BD_0 = q_BD[0]\n",
    "        q_BD_K = q_BD[-1]\n",
    "        \n",
    "                p_g_1 = q_LS_K*(1-q_LF_K) + q_LF_K*(1-q_LS_K)\n",
    "        p_g_0 = q_LS_K*q_LF_K + (1-q_LS_K)*(1-q_LF_K)    \n",
    "        E_log_p_z_BD = q_BD_K*(-torch.log(1+torch.exp(-self.w_0BD - self.w_aBD*a_BD - (self.w_eBD**2)/2)*(torch.exp(-self.w_gBD)*p_g_1 + p_g_0))) + (1-q_BD_K)*(-torch.log(1+torch.exp(-self.w_0BD - self.w_aBD*a_BD - (self.w_eBD**2)/2)*(torch.exp(self.w_gBD)*p_g_1+p_g_0)))\n",
    "        E_log_p_z_LS = q_LS_K*(-torch.log(1+torch.exp(-self.w_0LS - self.w_aLS*a_LS + (self.w_eLS**2)/2))) + (1-q_LS_K)*(-torch.log(1+torch.exp(self.w_0LS + self.w_aLS*a_LS + (self.w_eLS**2)/2)))\n",
    "        E_log_p_z_LF = q_LF_K*(-torch.log(1+torch.exp(-self.w_0LF - self.w_aLF*a_LF + (self.w_eLF**2)/2))) + (1-q_LF_K)*(-torch.log(1+torch.exp(self.w_0LF + self.w_aLF*a_LF + (self.w_eLF**2)/2)))\n",
    "        E_log_p_z = torch.mean(E_log_p_z_BD + E_log_p_z_LS + E_log_p_z_LF)        \n",
    "\n",
    "        E_log_p_xz = (- torch.log(x) - torch.log(torch.abs(torch.sqrt(self.w_ex))) \n",
    "                   - (torch.log(x)**2)/(2*(self.w_ex))\n",
    "                   + (torch.log(x)*(self.w_BDx*q_BD_K + self.w_LSx*q_LS_K + self.w_LFx*q_LF_K + self.w_0x))/(self.w_ex)\n",
    "                   - ((self.w_BDx**2)*q_BD_K + (self.w_LSx**2)*q_LS_K + (self.w_LFx**2)*q_LF_K + self.w_ex**2 + self.w_0x**2)/(2*(self.w_ex))\n",
    "                   - (self.w_BDx*self.w_LSx*q_BD_K*q_LS_K + self.w_BDx*self.w_LFx*q_BD_K*q_LF_K + self.w_LSx*self.w_LFx*q_LS_K*q_LF_K)/(self.w_ex)\n",
    "                   - (self.w_BDx*self.w_0x*q_BD_K + self.w_LSx*self.w_0x*q_LS_K + self.w_LFx*self.w_0x*q_LF_K)/(self.w_ex))\n",
    "        return q_LS_mu, q_LS_var, q_LS_0, q_LS_K, self.log_det_j_LS, q_LF_mu, q_LF_var, q_LF_0, q_LF_K, self.log_det_j_LF, q_BD_mu, q_BD_var, q_BD_0, q_BD_K, self.log_det_j_BD, E_log_p_xz, E_log_p_z"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
